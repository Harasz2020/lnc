<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>D&amp;D Server</title>
    <script type="text/javascript" src="dad.js"></script>
    <script type="text/javascript">
      var mouseX, mouseY, leftMouseDown=false, rightMouseDown=false;
      var shiftPressed = false;
      var canvas, ctx;
            
      function compose() {
        if (hiddenCanvases.length == 0) return;
        
        canvas.width  = window.innerWidth-20;
        if (Math.round(100.0 * canvas.width / canvas.height) != 
            Math.round(100.0 * hiddenCanvases[0].width / hiddenCanvases[0].height))  {
          canvas.height = canvas.width * hiddenCanvases[0].height / hiddenCanvases[0].width;
          updatePositionMarkers();
        }
        
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        for (let l = 0;l<hiddenCanvases.length;++l) {
          let c = hiddenCanvases[l];
          ctx.drawImage(c, 0,0, canvas.width, canvas.height);
        }
        
        ctx.globalAlpha = 0.8;
        ctx.drawImage(positionCanvas, 0,0, canvas.width, canvas.height);
        ctx.globalAlpha = 1.0;
      }
      
      function processBuffer(buffer) {
        try {
          let message = deserializeMessage(buffer);
          switch (message.constructor) {
            case PaintMessage: {
              let layerCtx = hiddenCanvases[message.target].getContext('2d');
              let sprite = layerCtx.createImageData(message.brushSize, message.brushSize);
              for (let y = 0; y < sprite.height; ++y) {
                for (let x = 0; x < sprite.width; ++x) {
                  let i = (x+y*sprite.width)*4;
                  sprite.data[i + 0] = message.r;
                  sprite.data[i + 1] = message.g;
                  sprite.data[i + 2] = message.b;
                  sprite.data[i + 3] = message.a;
                }
              }
              layerCtx.putImageData(sprite, message.posX, message.posY);
              compose();
              break;
            }
            case InitMessage: {
              cursors.clear();
              hiddenCanvases = [];
              serverWidth = message.width;
              serverHeight = message.height;
              
              for (let l = 0;l<message.layerCount;++l) {
                hiddenCanvases.push(createCanvas(message.width,message.height));
                let layerCtx = hiddenCanvases[hiddenCanvases.length-1].getContext('2d');
                let initialImageData = layerCtx.createImageData(message.width, message.height);
                const offset = l * message.width*message.height*4;
                
                for (let i = 0;i<message.width*message.height*4;i++) {
                  initialImageData.data[i] = message.imageData[i+offset];
                }
                
                layerCtx.putImageData(initialImageData, 0, 0);
              }
              
              positionCanvas = createCanvas(message.width,message.height);
              activeRealmName = message.name;
              activeRealm = message.id;
              
              for (let i = 0; i < message.cursors.length; ++i) {
                cursors.set(message.cursors[i].id, [message.cursors[i].name, message.cursors[i].posX, message.cursors[i].posY, message.id]);
              }
              updatePositionMarkers();
              compose();
              document.getElementById("realmText").value = activeRealm;
              document.getElementById("title").innerHTML = "You are here: " + activeRealmName;
              break;
            }
            case ClearMessage: {
              let layerCtx = hiddenCanvases[message.target].getContext('2d');
              let sprite = layerCtx.createImageData(hiddenCanvases[message.target].width, hiddenCanvases[message.target].height);
              for (let y = 0; y < hiddenCanvases[message.target].height; ++y) {
                for (let x = 0; x < hiddenCanvases[message.target].width; ++x) {
                  let i = (x+y*sprite.width)*4;
                  sprite.data[i + 0] = message.r;
                  sprite.data[i + 1] = message.g;
                  sprite.data[i + 2] = message.b;
                  sprite.data[i + 3] = message.a;
                }
              }
              layerCtx.putImageData(sprite, 0,0);
              compose();
              break;
            }
            case PositionMessage: {
              if (message.realm == activeRealm)  {
                cursors.set(message.id, [message.name, message.posX, message.posY, message.realm]);
                updatePositionMarkers();
                compose();
              } else {
                if (cursors.delete(message.id)) {
                  updatePositionMarkers();
                  compose();                
                }
              }
              break;
            }
          }
        } catch (e) {
          console.log(e)
        }
      }
      
      function overrideLayer(){
        if(socket.readyState == 1)
          socket.send(new ClearMessage(color.r, color.g, color.b, color.a, currentTarget).serialize());
      }

      function eraseLayer(){
        if(socket.readyState == 1)
          socket.send(new ClearMessage(0,0,0,0,currentTarget).serialize());
      }
      
      function applyColor() {
        let hueLabel = document.getElementById("hueLabel");
        color = HSVtoRGB(h,s,v);
        hueLabel.style.backgroundColor = rgb(color.r,color.g,color.b);
      }
      
      function init() {
        loadState();
        
        let nameText = document.getElementById("nameText");
        nameText.value = name;
        nameText.oninput = function() {
          let nameText = document.getElementById("nameText");
          name = nameText.value;
          saveState();
        }
        
        let realmText = document.getElementById("realmText");
        realmText.value = activeRealm;

        realmText.onchange = function() {
          let realmText = document.getElementById("realmText");
          activeRealm = realmText.value;
          if(socket.readyState == 1)
            socket.send(new ChangeRealmMessage(activeRealm, 0).serialize());
          saveState();
        }
        
        let hueSlider = document.getElementById("hueSlider");
        let satSlider = document.getElementById("satSlider");
        let valueSlider = document.getElementById("valueSlider");
        
        hueSlider.value = h*100;
        satSlider.value = s*100;
        valueSlider.value = v*100;
        applyColor();
        
        hueSlider.oninput = function() {
          h = this.value/100;
          applyColor();
          saveState();
        }
        satSlider.oninput = function() {
          s = this.value/100;
          applyColor();
          saveState();
        }
        valueSlider.oninput = function() {
          v = this.value/100;
          applyColor();
          saveState();
        }

        let brushSizeSlider = document.getElementById("brushSizeSlider");
        brushSizeSlider.value = brushSize;
        brushSizeSlider.oninput = function() {
          brushSize = this.value;
          saveState();
        }
                
        window.addEventListener('resize', function(event) {
          compose();
        }, true);
        
        window.onkeydown = function(event){
          switch (event.key) {  
            case "Shift" :
              shiftPressed = true;
              break;
            default:
              console.log(event);
          };
        };

        window.onkeyup = function(event){
          switch (event.key) {  
            case "Shift" : 
              shiftPressed = false;
              break;
            default:
              console.log(event);
          };
        };
        
        applyColor();
        
        canvas = document.getElementById("drawArea");
        canvas.onmousemove   = handleMouseMove;
        canvas.onmousedown   = handleMouseDown;
        canvas.onmouseup     = handleMouseUp;
        canvas.oncontextmenu = handleContextMenu;
        
        canvas.addEventListener("touchmove", event => {
          var rect = event.target.getBoundingClientRect();
          mouseX = event.touches[0].clientX - rect.left;
          mouseY = event.touches[0].clientY - rect.top;
          event.preventDefault();
          dropPaint(color);
        });
  
/*
        canvas.addEventListener("wheel", event => {
          const delta = 0.4 * Math.sign(event.deltaY);
          event.preventDefault();
          brushSize = Math.min(Math.max(brushSize-delta, 1), 200);
        });
*/
        
        ctx = canvas.getContext("2d");
        ctx.globalCompositeOperation = "source-over";
        
        ctx.fillStyle = "rgba(0,0,255,0.1)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        createSocket();
        
      }

      function setPosition() {
        if(socket.readyState == 1) {
          socket.send(new PositionMessage(activeRealm, 0, serverWidth * mouseX/canvas.width,
            serverHeight * mouseY/canvas.height,
            name).serialize());
        }
      }

      function dropPaint(rgba) {
        if(socket.readyState == 1)
          socket.send(new PaintMessage(serverWidth * mouseX/canvas.width,
                                       serverHeight * mouseY/canvas.height,
                                       rgba.r, rgba.g, rgba.b, rgba.a, 
                                       Math.round(brushSize), currentTarget).serialize());
      }
      
      function handleContextMenu() {
        event.preventDefault();
        return false;
      }
      
      function handleMouseDown(event) {
        if (event.button === 0) {
          leftMouseDown = true;
          dropPaint(color);
        }
        if (event.button === 2) {
          rightMouseDown = true;
          dropPaint(eraser);
        }
        
        event.preventDefault();
      }

      function handleMouseUp(event) {
        if (event.button === 0)
          leftMouseDown = false;
        if (event.button === 2)
          rightMouseDown = false;
        event.preventDefault();
      }

      function handleMouseMove(event) {
        var rect = event.target.getBoundingClientRect();
        mouseX = event.clientX - rect.left;
        mouseY = event.clientY - rect.top;
        event.preventDefault();
        if (leftMouseDown) dropPaint(color);
        if (rightMouseDown) dropPaint(eraser);
        if (shiftPressed) setPosition();
      }
      
      
      function updatePositionMarkers() {

        // TODO: consider resizing "positionCanvas" along with "canvas" and adjusting the coordinates
        
        let layerCtx = positionCanvas.getContext('2d');
        layerCtx.clearRect(0, 0, positionCanvas.width, positionCanvas.height);
        layerCtx.font = "20px Arial";
        layerCtx.fillStyle = 'black';
        for (const [key, value] of cursors.entries()) {
          layerCtx.beginPath();
          layerCtx.arc(value[1], value[2], 5, 0, 2 * Math.PI, false);
          layerCtx.fill();
          layerCtx.fillText(value[0], value[1]+8, value[2]-8);
        }
        
/*        
      case PositionMessage: {
        if (message.realm == activeRealm) {
          cursors.set(message.id) = [message.name, message.posX, message.posY, message.realm];
          updatePositionMarkers();
        }
        
  
        positionCanvas
        */
      }
      
    </script>
  </head>

  <body onload="init();" style="background-color:#BBBBBB;">
    <center>
    <h1 id="title">Connecting to D&amp;D Server</h1>
    <div id="hueLabel">
      <input id="nameText" type="text">
      <input id="realmText" type="text">
      <input type="button" value="Change Realm" id="submitRealm"/>
      <input type="range" min="0" max="100" value="1" class="slider" id="hueSlider">
      <input type="range" min="0" max="100" value="100" class="slider" id="satSlider">
      <input type="range" min="0" max="100" value="100" class="slider" id="valueSlider">
      <input type="range" min="1" max="100" value="50" class="slider" id="brushSizeSlider">
    </div>
    <canvas id="drawArea" width="800" height="600"></canvas>
    <p id="status"></p>
    </center>
  </body>
</html>
        