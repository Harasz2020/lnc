<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>WebSocket Multiuser Painter</title>
    <script type="text/javascript">
      
      function deserializeMessage(buffer) {
        if (buffer instanceof Uint8Array && buffer.length > 0) {
          let type = buffer[0];
          switch (type) {
            case 0 :
              return InitMessage.deserialize(buffer);
            case 1 :
              return PaintMessage.deserialize(buffer);
            case 2 :
              return ClearMessage.deserialize(buffer);
            default:
              throw new Error("invalid message type");
          };
        } else {
          throw new Error("invalid message buffer");
        }
      }
            
      class PaintMessage {
        constructor(posX, posY, r, g, b, a, brushSize, target) {
          this.posX = posX;
          this.posY = posY;
          this.r = r;
          this.g = g;
          this.b = b;
          this.a = a;
          this.brushSize = brushSize;
          this.target = target;
        }
        
        serialize() {
          return new Uint8Array([1, (this.posX >> 8) & 0xff, this.posX & 0xff, (this.posY >> 8) & 0xff, this.posY & 0xff, this.r, this.g, this.b, this.a,
                                (this.brushSize >> 8) & 0xff, this.brushSize & 0xff, this.target] );
        }
                
        static deserialize(buffer) {
          if (buffer.length === 12) {
            return new PaintMessage((buffer[1] << 8) + buffer[2], (buffer[3] << 8) + buffer[4], buffer[5], buffer[6], buffer[7], buffer[8], (buffer[9] << 8) + buffer[10], buffer[11]);
          } else {
            throw new Error("invalid message length");
          }
        }
      };
      
      class ClearMessage {
        constructor(r, g, b, a, target) {
          this.r = r;
          this.g = g;
          this.b = b;
          this.a = a;
          this.target = target;
        }
        
        serialize() {
          return new Uint8Array([2, this.r, this.g, this.b, this.a, this.target] );
        }
        
        static deserialize(buffer) {
          if (buffer.length === 6) {
            return new ClearMessage(buffer[1], buffer[2], buffer[3], buffer[4], buffer[5]);
          } else {
            throw new Error("invalid message length");
          }
        }
      };
      
      class InitMessage {
        constructor(imageData, width, height, layerCount) {
          this.width = width;
          this.height = height;
          this.imageData = imageData;
          this.layerCount = layerCount;
        }
                
        static deserialize(buffer) {
          if (buffer.length < 6) {
            throw new Error("invalid message length");
          }
          
          let width  = (buffer[1] << 8) + buffer[2];
          let height = (buffer[3] << 8) + buffer[4];
          let layerCount = buffer[5];
          
          return new InitMessage(buffer.slice(6),width,height,layerCount);
        }
      };
      
      var mouseX, mouseY, leftMouseDown=false, rightMouseDown=false;
      var brushSize = 10;
      var currentTarget = 2;
      var canvas, ctx;
      var socket;
      var serverWidth;
      var serverHeight;
      var h,s,v;
      var color = {r:255,g:0,b:0,a:255};
      const eraser = {r:0,g:0,b:0,a:0};
      
      var hiddenCanvases = [];

      function HSVtoRGB(h, s, v) {
        let r, g, b, i, f, p, q, t;
        i = Math.floor(h * 6);
        f = h * 6 - i;
        p = v * (1 - s);
        q = v * (1 - f * s);
        t = v * (1 - (1 - f) * s);
        switch (i % 6) {
          case 0: r = v, g = t, b = p; break;
          case 1: r = q, g = v, b = p; break;
          case 2: r = p, g = v, b = t; break;
          case 3: r = p, g = q, b = v; break;
          case 4: r = t, g = p, b = v; break;
          case 5: r = v, g = p, b = q; break;
        }
        return {
          r: Math.round(r * 255),
          g: Math.round(g * 255),
          b: Math.round(b * 255),
          a: 255
        };
      }
      
      function createCanvas(width, height) {
        let c = document.createElement('canvas');
        c.setAttribute('width', width);
        c.setAttribute('height', height);
        return c;
      }
      
      function compose() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        for (let l = 0;l<hiddenCanvases.length;++l) {
          let c = hiddenCanvases[l];
          ctx.drawImage(c, 0,0, canvas.width, canvas.height);
        }
      }
      
      function processBuffer(buffer) {
        try {
          let message = deserializeMessage(buffer);
          switch (message.constructor) {
            case PaintMessage: {
              let layerCtx = hiddenCanvases[message.target].getContext('2d');
              let sprite = layerCtx.createImageData(message.brushSize, message.brushSize);
              for (let y = 0; y < sprite.height; ++y) {
                for (let x = 0; x < sprite.width; ++x) {
                  let i = (x+y*sprite.width)*4;
                  sprite.data[i + 0] = message.r;
                  sprite.data[i + 1] = message.g;
                  sprite.data[i + 2] = message.b;
                  sprite.data[i + 3] = message.a;
                }
              }
              layerCtx.putImageData(sprite, message.posX, message.posY);
              compose();
              break;
            }
            case InitMessage: {
              hiddenCanvases = [];
              serverWidth = message.width;
              serverHeight = message.height;
              
              for (let l = 0;l<message.layerCount;++l) {
                hiddenCanvases.push(createCanvas(message.width,message.height));
                let layerCtx = hiddenCanvases[hiddenCanvases.length-1].getContext('2d');
                let initialImageData = layerCtx.createImageData(message.width, message.height);
                const offset = l * message.width*message.height*4;
                
                for (let i = 0;i<message.width*message.height*4;i++) {
                  initialImageData.data[i] = message.imageData[i+offset];
                }
                
                layerCtx.putImageData(initialImageData, 0, 0);
              }
              compose();
              document.getElementById("title").innerHTML = "D&D Map Explorer";
              break;
            }
            case ClearMessage: {
              let layerCtx = hiddenCanvases[message.target].getContext('2d');
              let sprite = layerCtx.createImageData(hiddenCanvases[message.target].width, hiddenCanvases[message.target].height);
              for (let y = 0; y < hiddenCanvases[message.target].height; ++y) {
                for (let x = 0; x < hiddenCanvases[message.target].width; ++x) {
                  let i = (x+y*sprite.width)*4;
                  sprite.data[i + 0] = message.r;
                  sprite.data[i + 1] = message.g;
                  sprite.data[i + 2] = message.b;
                  sprite.data[i + 3] = message.a;
                }
              }
              layerCtx.putImageData(sprite, 0,0);
              compose();
              break;
            }
          }
        } catch (e) {
          console.log(e)
        }
      }
      
      function rgb(r, g, b){
        return ["rgb(",r,",",g,",",b,")"].join("");
      }
      
      function overrideLayer(){
        if(socket.readyState == 1)
          socket.send(new ClearMessage(color.r, color.g, color.b, color.a, currentTarget).serialize());
      }

      function eraseLayer(){
        if(socket.readyState == 1)
          socket.send(new ClearMessage(0,0,0,0,currentTarget).serialize());
      }
      
      function applyColor() {
        let hueLabel = document.getElementById("hueLabel");
        color = HSVtoRGB(h,s,v);
        hueLabel.style.backgroundColor = rgb(color.r,color.g,color.b);
      }
      
      function init() {
        let hueSlider = document.getElementById("hueSlider");
        hueSlider.oninput = function() {
          h = this.value/100;
          applyColor();
        }
        let satSlider = document.getElementById("satSlider");
        satSlider.oninput = function() {
          s = this.value/100;
          applyColor();
        }
        let valueSlider = document.getElementById("valueSlider");
        valueSlider.oninput = function() {
          v = this.value/100;
          applyColor();
        }
                
        
        hueSlider.value = Math.round(Math.random() * 100);
        satSlider.value = 100;
        valueSlider.value = 100;
        
        h = hueSlider.value/100;
        s = satSlider.value/100;
        v = valueSlider.value/100;
        applyColor();
        
        canvas = document.getElementById("drawArea");
        canvas.onmousemove   = handleMouseMove;
        canvas.onmousedown   = handleMouseDown;
        canvas.onmouseup     = handleMouseUp;
        canvas.oncontextmenu = handleContextMenu;
        
        
        canvas.addEventListener("touchmove", event => {
          var rect = event.target.getBoundingClientRect();
          mouseX = event.touches[0].clientX - rect.left;
          mouseY = event.touches[0].clientY - rect.top;
          event.preventDefault();
          dropPaint(color);
        });
  
        canvas.addEventListener("wheel", event => {
          const delta = 0.4 * Math.sign(event.deltaY);
          event.preventDefault();
          brushSize = Math.min(Math.max(brushSize-delta, 1), 200);
        });
        
        ctx = canvas.getContext("2d");
        ctx.globalCompositeOperation = "source-over";
        
        ctx.fillStyle = "rgba(0,0,255,0.1)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        socket = new WebSocket('ws://134.91.11.186:2000');
        //socket = new WebSocket('ws://134.91.11.162:2000');
        //socket = new WebSocket('ws://localhost:2000');
        
        socket.onopen = function () {
          document.getElementById("status").innerHTML += "Connection open<br>";
        };
        
        socket.onmessage = function (msg) {
          if (typeof msg.data === "string")
            document.getElementById("status").innerHTML += "Received String Message: " + msg.data +"<br>";
          else {
            let reader = new FileReader();
            reader.readAsArrayBuffer(msg.data);
            reader.addEventListener("loadend", function(e) {
              processBuffer(new Uint8Array(e.target.result))
            });
          }
        };
        
        socket.onclose = function() {
          document.getElementById("status").innerHTML += "Connection closed" +"<br>";
        };
        
      }

      function dropPaint(rgba) {
        if(socket.readyState == 1)
          socket.send(new PaintMessage(serverWidth * mouseX/canvas.width,
                                       serverHeight * mouseY/canvas.height,
                                       rgba.r, rgba.g, rgba.b, rgba.a, Math.round(brushSize), currentTarget).serialize());
      }
      
      function handleContextMenu() {
        event.preventDefault();
        return false;
      }
      
      function handleMouseDown(event) {
        if (event.button === 0) {
          leftMouseDown = true;
          dropPaint(color);
        }
        if (event.button === 2) {
          rightMouseDown = true;
          dropPaint(eraser);
        }
        
        event.preventDefault();
      }

      function handleMouseUp(event) {
        if (event.button === 0)
          leftMouseDown = false;
        if (event.button === 2)
          rightMouseDown = false;
        event.preventDefault();
      }

      function handleMouseMove(event) {
        var rect = event.target.getBoundingClientRect();
        mouseX = event.clientX - rect.left;
        mouseY = event.clientY - rect.top;
        event.preventDefault();
        if (leftMouseDown) dropPaint(color);
        if (rightMouseDown) dropPaint(eraser);
      }
    </script>
  </head>

  <body onload="init();" style="background-color:#BBBBBB;">
    <center>
    <h1 id="title">Connecting to Paint-Server</h1>
    <div id="hueLabel">
      <input type="range" min="0" max="100" value="1" class="slider" id="hueSlider">
      <input type="range" min="0" max="100" value="100" class="slider" id="satSlider">
      <input type="range" min="0" max="100" value="100" class="slider" id="valueSlider">
    </div>
    <canvas id="drawArea" width="800" height="600"></canvas>
    <p id="status"></p>
    </center>
  </body>
</html>
        